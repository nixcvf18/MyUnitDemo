package com.nixcvf18.myunitdemo.data;

public class GHADetailsResults {


    /**
     * data : {"_id":"5f02eb55808d6d2fe6b56f31","author":"Espoir","category":"GanHuo","content":"","createdAt":"2020-07-06 17:13:57","desc":"是时候提高你撸RecycleView的效率了，简单而方便！","email":"386707112@qq.com","images":["https://gank.io/images/52f5fcc58dcd4f8c854f073e13a88d30"],"index":0,"isOriginal":false,"license":"","likeCounts":0,"likes":[],"markdown":"\r\n## 前言\r\n在项目开发中，总离不开列表，说到列表，就会有无穷无尽的 Adapter 需要你去实现。从而出现了很多优秀的 adapter 库。\r\n不过很多库功能都很全面了，有很多个类，很多功能，但是实际上只用其中的一两个我感觉是很多人的现状。所以自己实现一个使用起来顺手的是一个不错的选择，特别是用在一些不是很复杂的列表时。\r\n\r\n## 效果\r\n先看看使用效果，激发一下你为数不多继续阅读的激情：\r\n```kotlin\r\n//单类型列表，默认 LinearLayoutManager\r\nrecycleView.setup<NumberInfo> {\r\n    dataSource(initData())\r\n    adapter {\r\n        addItem(R.layout.layout_item) {\r\n            bindViewHolder { data, _, _ ->\r\n                setText(R.id.number, data?.number.toString())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//多类型列表\r\nrecycleView.setup<Any> {\r\n    withLayoutManager { LinearLayoutManager(context) }\r\n    dataSource(data)\r\n    adapter {\r\n        addItem(R.layout.item_setion_header) {\r\n            isForViewType { data, _ -> data is SectionHeader }\r\n            bindViewHolder { data, _, _ ->\r\n                val header = data as SectionHeader\r\n                setText(R.id.section_title, header.title)\r\n            }\r\n        }\r\n        addItem(R.layout.item_user) {\r\n            isForViewType { data, _ -> data is User }\r\n            bindViewHolder { data, _, _ ->\r\n                val user = data as User\r\n                setText(R.id.name, user.name)\r\n                setImageResource(R.id.avatar, user.avatarRes)\r\n                //如果你的控件找不到方便赋值的方法，可以通过 findViewById 去查找\r\n                val phone = findViewById<TextView>(R.id.phone)\r\n                phone.text = user.phone\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n嗯....，感觉还可以，最少的情况下可以把一个列表代码用 10 几行就完成了。\r\n\r\n## 完整代码地址\r\n先贴完整代码地址，没地址的文章是没灵魂的：[EfficientAdapter](https://github.com/EspoirX/EfficientAdapter)  \r\n我把它命名为 EfficientAdapter ，意为高效的意思，事实上它只有 3 个文件。  \r\n至于如何使用，在地址上已经描述了，所以这篇文章主要是讲一下实现的思路。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/7/6/17321d4bc743afc4?w=240&h=240&f=gif&s=12507)\r\n\r\n\r\n## 实现思路\r\n对 Adapter 的封装，其实无非就是对 Adapter 里面的几个回调方法进行封装罢了，最常用的方法是先定义好一个存放 ViewHolder\r\n的列表，然后在各个回调中获取这些 ViewHolder，然后实现逻辑。\r\n\r\n那么其中最操蛋的是哪个回调方法的封装呢？我认为是 getItemViewType。事实上你可以在很多框架中看到让你实现获取 ViewType 的回调方法。\r\n\r\n一步一步来，先说 ViewHolder 的封装\r\n\r\n在 EfficientAdapter 里面，我把 ViewHolder 的封装写成了 BaseViewHolder：\r\n```kotlin\r\nclass BaseViewHolder(parent: ViewGroup, resource: Int) : RecyclerView.ViewHolder(\r\n        LayoutInflater.from(parent.context).inflate(resource, parent, false)\r\n)\r\n```\r\n这就是我的封装，够简单吧。\r\n\r\n想什么呢，当然没这么简单，想要在上面使用效果代码中那样实现 ViewHolder 的具体逻辑，还需要有 isForViewType，bindViewHolder 等方法。所以我要定义一个类，去提供这些方法：\r\n\r\n```kotlin\r\nabstract class ViewHolderCreator<T> {\r\n    abstract fun isForViewType(data: T?, position: Int): Boolean\r\n    abstract fun getResourceId(): Int\r\n    abstract fun onBindViewHolder(\r\n            data: T?, items: MutableList<T>?,\r\n            position: Int,  holder: ViewHolderCreator<T>\r\n    )\r\n\r\n    var itemView: View? = null\r\n\r\n    fun registerItemView(itemView: View?) {\r\n        this.itemView = itemView\r\n    }\r\n\r\n    fun <V : View> findViewById(viewId: Int): V {\r\n        checkItemView()\r\n        return itemView!!.findViewById(viewId)\r\n    }\r\n\r\n    private fun checkItemView() {\r\n        if (itemView == null) {\r\n            throw NullPointerException(\"itemView is null\")\r\n        }\r\n    }\r\n}\r\n```\r\n在 ViewHolderCreator 中，getResourceId 和 onBindViewHolder 方法相信都知道是干嘛的，而 isForViewType 方法是用来判断 ViewType 的，注意它返回类型是 Boolean，这个方法会在下面讲到。因为我想在 onBindViewHolder 中能方便的拿到 view，所以有了 registerItemView 和 findViewById 等其他方法。\r\n\r\n以上就是 ViewHolder 的所有封装，接下来就对 Adapter 的封装。\r\n\r\n```kotlin\r\nopen class EfficientAdapter<T> : RecyclerView.Adapter<RecyclerView.ViewHolder>() {\r\n    var items: MutableList<T>? = mutableListOf()\r\n    private val typeHolders: SparseArrayCompat<ViewHolderCreator<T>> = SparseArrayCompat()\r\n}\r\n```\r\nAdapter 首先需要一个泛型用来表示传入的实体类类型，定义了一个 item 列表用来做数据源。ViewHolder 的集合使用一个 SparseArrayCompat 去存储。之所以用 SparseArray ，是因为我想把 ViewType 做为 key。\r\n\r\n所以，在 onCreateViewHolder 回调方法中，需要根据 viewType 参数在 typeHolders 中取到具体的 ViewHolderCreator：\r\n\r\n```kotlin\r\nprivate fun getHolderForViewType(viewType: Int): ViewHolderCreator<T>? {\r\n    return typeHolders.get(viewType)\r\n}\r\n\r\noverride fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\r\n    val holder = getHolderForViewType(viewType)\r\n            ?: throw NullPointerException(\"No Holder added for ViewType $viewType\")\r\n    return BaseViewHolder(parent, holder.getResourceId())\r\n}\r\n```\r\n这样，就可以通过 getHolderForViewType 方法，在 typeHolders 中获取到对应的 ViewHolderCreator，然后根据 ViewHolderCreator 中的信息去创建一个新的 ViewHolder。如果找不到，就抛一个空指针异常。\r\n\r\n同样道理，onBindViewHolder 回调方法也可以这么做：\r\n\r\n```kotlin\r\noverride fun onBindViewHolder(viewHolder: RecyclerView.ViewHolder, position: Int) {\r\n    onBindViewHolder(viewHolder, position, mutableListOf())\r\n}\r\n\r\noverride fun onBindViewHolder(viewHolder: RecyclerView.ViewHolder, position: Int, payloads:MutableList<Any>) {\r\n    val holder = getHolderForViewType(viewHolder.itemViewType)\r\n            ?: throw NullPointerException(\"No Holder added for ViewType \" + viewHolder.itemViewType)\r\n    holder.registerItemView(viewHolder.itemView)\r\n    holder.onBindViewHolder(items?.get(position), items, position, holder)\r\n}\r\n```\r\n注意的是 onBindViewHolder 回调方法有两个，他们的区别就不说了，这里两个都实现了逻辑，当然你也可以只实现一个。\r\n\r\n还剩下 getItemCount 和 getItemViewType 回调方法了，getItemCount 其实没什么好说的：\r\n\r\n```kotlin\r\noverride fun getItemCount(): Int = items?.size ?: 0\r\n```\r\n\r\n先不说如何实现 getItemViewType ，先说说怎么添加数据到 typeHolders 中：\r\n\r\n```kotlin\r\nfun register(holder: ViewHolderCreator<T>) = apply {\r\n    var viewType: Int = typeHolders.size()\r\n    while (typeHolders.get(viewType) != null) {\r\n        viewType++\r\n    }\r\n    typeHolders.put(viewType, holder)\r\n}\r\n```\r\ntypeHolders 的类型是 SparseArrayCompat，这里我用 ViewType 作为 key，register 方法中，可以看到没每注册一次，viewType 就自动加一（因为 typeHolders 的长度会变长），达到了不会重复的效果，到时候在实现 getItemViewType 的时候，就直接取出来即可。避免了具体业务的干扰。\r\n\r\n最后看看 getItemViewType 的实现：\r\n\r\n```kotlin\r\noverride fun getItemViewType(position: Int): Int {\r\n    if (items == null) {\r\n        throw NullPointerException(\"adapter data source is null\")\r\n    }\r\n    for (i in 0 until typeHolders.size()) {\r\n        val holder = typeHolders.valueAt(i)\r\n        val data = items?.getOrNull(position)\r\n        if (holder.isForViewType(data, position)) {\r\n            return typeHolders.keyAt(i)\r\n        }\r\n    }\r\n\r\n    //找不到匹配的 viewType\r\n    throw NullPointerException(\r\n            \"No holder added that matches at position=$position in data source\")\r\n}\r\n```\r\n\r\n该方法的思路是通过遍历 typeHolders，通过 ViewHolderCreator 的 isForViewType 方法来判断是否符合条件，如果符合，则在 typeHolders 中取出 viewType 出来返回。\r\n\r\n因为 typeHolders 中的 viewType 是自增的，所以 getItemViewType 的返回值会是 0，1，2，3...\r\n\r\nisForViewType 在实际中如何实现？\r\n\r\n举个例子：  \r\n如果你的数据源由多个实体类组成，比如：\r\n```java\r\nprivate List<Object> data = new ArrayList<>();\r\ndata.add(new User(\"Marry\", 17, R.drawable.icon2, \"123456789XX\"));\r\ndata.add(new SectionHeader(\"My Images\"));\r\ndata.add(new Image(R.drawable.cover1));\r\n```\r\n\r\n那么在构建 EfficientAdapter 时，泛型传入的自然是 Object，然后在 isForViewType 方法中你可以这样区分类型：\r\n```java\r\n // 代表这是 User 类型\r\n public boolean isForViewType(Object data, int position) {\r\n   return data instanceof User;\r\n}\r\n\r\n // 代表这是 SectionHeader 类型\r\n public boolean isForViewType(Object data, int position) {\r\n   return data instanceof SectionHeader;\r\n}\r\n\r\n // 代表这是 Image 类型\r\n public boolean isForViewType(Object data, int position) {\r\n   return data instanceof Image;\r\n}\r\n```\r\n\r\n如果你的数据源只有一个实体类，但是实体类里面有某个字段可以区分类型，你可以这样：\r\n```java\r\n // 代表这是 User 类型\r\n public boolean isForViewType(ListInfo data, int position) {\r\n   return data.type = ListInfo.USER\r\n}\r\n\r\n // 代表这是 SectionHeader 类型\r\n public boolean isForViewType(ListInfo data, int position) {\r\n   return data.type = ListInfo.HEADER\r\n}\r\n\r\n // 代表这是 Image 类型\r\n public boolean isForViewType(ListInfo data, int position) {\r\n   return data.type = ListInfo.IMAGE\r\n}\r\n```\r\n其他情况可以根据具体的情况而定。\r\n\r\n到这里，已经完成 Adapter 的封装了，接下来可以定义一些数据源的增删查改的方法，比如：\r\n```kotlin\r\n//绑定 RecyclerView\r\nfun attach(recyclerView: RecyclerView) = apply { recyclerView.adapter = this }\r\n\r\n//提交数据\r\nfun submitList(list: MutableList<T>) {\r\n    this.items?.clear()\r\n    this.items?.addAll(list)\r\n    notifyDataSetChanged()\r\n}\r\n```\r\n\r\n到这里，已经可以简单粗暴的使用了：\r\n```kotlin\r\nadapter = EfficientAdapter<SectionHeader>()\r\n        .register(object : ViewHolderCreator<SectionHeader>() {\r\n            override fun isForViewType(data: SectionHeader?, position: Int) = data != null\r\n            override fun getResourceId() = R.layout.item_setion_header\r\n\r\n            override fun onBindViewHolder(\r\n                    data: SectionHeader?,\r\n                    items: MutableList<SectionHeader>?, position: Int,\r\n                    holder: ViewHolderCreator<SectionHeader>\r\n            ) {\r\n                setText(R.id.section_title, data.title)\r\n            }\r\n        }).attach(recycle_view)\r\nadapter?.submitList(data)\r\n```\r\n\r\n但和使用效果差别有点大啊。所以，接下来就是 kotlin 发挥的时候了。\r\n\r\n## 扩展函数 与 DSL\r\n\r\n相信学过 kotlin 的都知道这两个东西，他们可以为我们的代码提供更多的可能。\r\n\r\n### ViewHolderCreator DSL\r\n\r\n由于 ViewHolderCreator 是一个抽象类，对它进行 DSL 封装需要一个默认的实现类（也许可以直接封装，但是我只能想到这种方法）：\r\n```kotlin\r\nclass ViewHolderDsl<T>(private val resourceId: Int) : ViewHolderCreator<T>() {\r\n    private var viewType: ((data: T?, position: Int) -> Boolean)? = null\r\n    private var viewHolder: ((data: T?, position: Int, holder: ViewHolderCreator<T>) -> Unit)? = null\r\n\r\n    fun isForViewType(viewType: (data: T?, position: Int) -> Boolean) {\r\n        this.viewType = viewType\r\n    }\r\n\r\n    fun bindViewHolder(holder: (data: T?, position: Int, holder: ViewHolderCreator<T>) -> Unit) {\r\n        viewHolder = holder\r\n    }\r\n\r\n    override fun isForViewType(data: T?, position: Int): Boolean {\r\n        return viewType?.invoke(data) ?: (data != null)\r\n    }\r\n\r\n    override fun getResourceId() = resourceId\r\n\r\n    override fun onBindViewHolder(\r\n            data: T?, items: MutableList<T>?, position: Int, holder: ViewHolderCreator<T>,\r\n            payloads: MutableList<Any>\r\n    ) {\r\n        viewHolder?.invoke(data, position, holder)\r\n    }\r\n}\r\n```\r\n代码比较清晰，就是对三个抽象方法的实现。由于 getResourceId 比较简单，所以直接放在构造方法中传值就好。\r\n\r\n实现好了 ViewHolderDsl，我们给 EfficientAdapter 定义一个扩展函数，用 DSL 的方式去调用 register 方法：\r\n\r\n```kotlin\r\nfun <T : Any> EfficientAdapter<T>.addItem(resourceId: Int, init: ViewHolderDsl<T>.() -> Unit) {\r\n    val holder = ViewHolderDsl<T>(resourceId)\r\n    holder.init()\r\n    register(holder)\r\n}\r\n```\r\n比较简单，就是创建好 ViewHolderDsl 后，调用 register 方法即可。\r\n\r\n到这里，其实已经可以用了，只要我们再写一个函数，用 DSL 的方式创建 Adapter 即可：\r\n\r\n```kotlin\r\nfun <T : Any> efficientAdapter(init: EfficientAdapter<T>.() -> Unit): EfficientAdapter<T> {\r\n    val adapter = EfficientAdapter<T>()\r\n    adapter.init()\r\n    return adapter\r\n}\r\n```\r\n\r\n所以上面那个简单粗暴的示例代码就可以变成这样：\r\n```kotlin\r\nadapter = efficientAdapter<Any> {\r\n    addItem(R.layout.item_setion_header) {\r\n        isForViewType { it != null }\r\n        bindViewHolder { data, _, _ ->\r\n            setText(R.id.section_title, data.title)\r\n        }\r\n    }\r\n}.attach(recycle_view)\r\nadapter?.submitList(data)\r\n```\r\n代码又清晰和简单了很多。由于在 ViewHolderDsl 中，isForViewType 的默认实现是 data!=null，所以如果是单类型列表，这个方法可以直接不写。\r\n\r\n\r\n虽然代码简单了很多，但这样总要定义 adapter 对象和绑定 RecycleView，所以更加优雅的方式就是给 RecycleView 定义一个扩展函数，把这些操作都包装起来。\r\n\r\n首先我们实现一个叫 RecycleSetup 的类，在这个类里面，把 RecycleView 的配置以及 Adapter 操作，数据源操作等通通包装起来：\r\n\r\n```kotlin\r\nclass RecycleSetup<T> internal constructor(private val recyclerView: RecyclerView) {\r\n\r\n    var items = mutableListOf<T>()\r\n    var adapter: EfficientAdapter<T>? = null\r\n    var context = recyclerView.context\r\n\r\n    fun dataSource(items: MutableList<T>) {\r\n        this.items.clear()\r\n        this.items = items\r\n    }\r\n\r\n    fun withLayoutManager(init: RecycleSetup<T>.() -> RecyclerView.LayoutManager) =\r\n            apply { recyclerView.layoutManager = init() }\r\n\r\n    fun adapter(init: EfficientAdapter<T>.() -> Unit) {\r\n        this.adapter = EfficientAdapter()\r\n        init.invoke(adapter!!)\r\n        recyclerView.adapter = adapter\r\n        adapter?.submitList(this.items)\r\n    }\r\n\r\n    fun submitList(list: MutableList<T>) {\r\n        this.items.clear()\r\n        this.items = list\r\n        adapter?.submitList(this.items)\r\n    }\r\n\r\n    fun getItem(position: Int): T = items[position]\r\n}\r\n```\r\n\r\n代码简单，相信大家都能看懂。\r\n\r\n有了这个类，最后，就可以给 RecycleView 实现扩展函数了：\r\n\r\n```kotlin\r\nfun <T> RecyclerView.setup(block: RecycleSetup<T>.() -> Unit): RecycleSetup<T> {\r\n    val setup = RecycleSetup<T>(this).apply(block)\r\n    if (layoutManager == null) {\r\n        layoutManager = LinearLayoutManager(context)\r\n    }\r\n    return setup\r\n}\r\n\r\nfun <T> RecyclerView.submitList(items: MutableList<T>) {\r\n    if (adapter != null && adapter is EfficientAdapter<*>) {\r\n        (adapter as EfficientAdapter<T>).submitList(items)\r\n    }\r\n}\r\n```\r\n\r\nlayoutManager 为空就默认实现 LinearLayoutManager。最后，上面那个简单粗暴的代码就可以写成跟一开始说那个效果一样了：\r\n```kotlin\r\nrecycleView.setup<SectionHeader> {\r\n    adapter {\r\n        addItem(R.layout.item_setion_header) {\r\n            bindViewHolder { data, _, _ ->\r\n                setText(R.id.section_title, data.title)\r\n            }\r\n        }\r\n    }\r\n}\r\nrecycleView.submitList(data)\r\n```\r\n\r\n完整代码和例子都在这里 [EfficientAdapter](https://github.com/EspoirX/EfficientAdapter)  ，有兴趣可以看看。","originalAuthor":"","publishedAt":"2020-07-06 17:13:57","stars":1,"status":0,"tags":[],"title":"是时候提高你撸RecycleView的效率了","type":"Android","updatedAt":"2020-07-06 17:13:57","url":"https://github.com/EspoirX/EfficientAdapter","views":3}
     * status : 100
     */

    private GHADetailsBean data;
    private int status;

    public GHADetailsBean getData() {
        return data;
    }

    public void setData(GHADetailsBean data) {
        this.data = data;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }
}
